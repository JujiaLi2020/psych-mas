load("C:/Users/julia/Box/Personal/Research/2026-1-psych-mas/R_Secmin/.RData")
write.csv(Resp, "../data/resp.csv")
setwd("C:/Users/julia/Box/Personal/Research/2026-1-psych-mas/R_Secmin")
write.csv(Resp, "../data/resp.csv")
write.csv(RT, "../data/rt.csv")
load("C:/Users/julia/psych-mas/R_Secmin/.RData")
model <- mirt(Resp, 1, itemtype='2PL')
library(mirt)
model <- mirt(Resp, 1, itemtype='2PL')
png(icc_path)
plot(model, type="trace")
for (i in loop){
x<-RT[,i]
hist(x,
main = paste("RT Distr. for Item",i),col= color,
breaks = 15)
mtext(paste("Correct Proportion:", p1[i]), cex= 0.5, col=2)
}
par(old.par)
dv<- function(RT, Resp, color ="lightgray"){
Resp<- as.data.frame(Resp)
RT<- as.data.frame(RT)
nresp<- nrow(Resp)
nrt<- ncol(RT)
nresp_cols<- ncol(Resp)
if (nrt != nresp_cols) stop("RT and Resp must have the same number of columns. RT: ", nrt, ", Resp: ", nresp_cols)
if (nresp == 0L) stop("Resp has no rows")
if (nrt == 0L) stop("RT has no columns")
loop <- 1:nrt
p <- colSums(Resp)
p1<- round(p/nresp, 2)
old.par <- par(mfrow = c(1,1), mar = c(5.1, 4.1, 4.1, 2.1),oma =c(0,0,0,0))
par(mfrow = c(3,4), oma =c(0.5,0.5,0.5,0.5), mar=c(2,2,3,2))
#i <- 1
for (i in loop){
x<-RT[,i]
hist(x,
main = paste("RT Distr. for Item",i),col= color,
breaks = 15)
mtext(paste("Correct Proportion:", p1[i]), cex= 0.5, col=2)
}
par(old.par)
}
# Only run when RT and Resp exist in the workspace (e.g. interactive R).
# When sourced from Python, we only define dv(); Python calls dv(rt_df, resp_df, ...).
if (exists("RT") && exists("Resp")) {
dv(RT, Resp)
}
unsprvs <- function(data,Flgd){
ID.A <- seq(1:length(data[,1]))
Flgd <- as.vector(unlist(Flgd))
Flgd <- factor(Flgd,levels = c(0,1),labels = c("cheated","not cheated"))
### KMeans #####
set.seed(520)
km.out.A <- kmeans(data,2,nstart=2)
km.out.A$size #kmeans cluster size
#### calculate the sensitivity
prop.cluster <- table(km.out.A$cluster)
det.A <- as.vector(which(km.out.A$cluster== which(prop.cluster < length(data[,1])/2)))
#not.Cheater.ID <- ID.A[-c(cheat.key.A)]
not.det.A <- as.vector(which(km.out.A$cluster== which(prop.cluster >= length(data[,1])/2)))
#### generate a confusion matrix as a function
kmeans.pred <- km.out.A$cluster
kmeans.pred <- factor(kmeans.pred,levels = c(1,2),labels = c("cheated","not cheated"))
kmeans.cm <- caret::confusionMatrix(kmeans.pred,Flgd)
k.max <- 5
wss.A <- sapply(1:k.max,function(k){kmeans(data,k,nstart=20)$tot.withinss})
### Mixture mutivaraite normal  ######
set.seed(520)
fit.cluster.A <- mclust::Mclust(data,G=1:2)
BIC <- NULL
for(j in 1:5)
{
rBIC <- mclust::mclustBIC(data, verbose = T,
initialization = list(hcPairs = mclust::hcRandomPairs(data)))
BIC <- mclust::mclustBICupdate(BIC, rBIC)
}
prop.cluster.m <- table(fit.cluster.A$classification)
det.m.A <- which(km.out.A$cluster== which(prop.cluster.m < length(data[,1])/2))
# confusion matrix
mixmul.pred <- fit.cluster.A$classification
mixmul.pred <- dplyr::case_when(
mixmul.pred == 1 ~ 2,
mixmul.pred == 2 ~ 1
)
mixmul.pred <- factor(mixmul.pred,levels = c(1,2), labels = c("cheated","not cheated"))
mixmul.cm <- caret::confusionMatrix(mixmul.pred,Flgd)
Unsupervised.Summary <- (list(
"Detected Cheating Cases Using Kmeans" = det.A,
"Kmeas Results" = kmeans.cm,
"Detected Cheating Cases Using FMM" = det.m.A,
"FMM Results" = mixmul.cm))
return(Unsupervised.Summary)
}
library(mclust)
unsprvs(data[[2]],Flagged)
#### data preparation
prepini <- function(RT, Resp) {
RT.new <- as.matrix(RT)
RT.new[RT.new== 0] <- NA
num.RT <- RT.new
num.RT[is.na(num.RT)] <-1
logRTs <- log(num.RT)
ini<- list(RT <- RT.new,
Resp <- as.data.frame(Resp),
al_hat <- 1/apply(logRTs,2,sd),
be_hat <- apply(logRTs,2,mean),
sp_hat <- mean(be_hat) - apply(logRTs,1,mean),
prec.sp <- 1,
mu.ipar <- c(mean(al_hat),mean(be_hat)),
prec.ipar <- diag(1,2,2)
)
names(ini) <- c("RT", "Resp", "ini.alpha", "ini.beta", "ini.speed",
"ini.prec.speed", "ini.mu.ipar", "ini.prec.ipar")
ini <- list(ini)
return(ini)
}
#### data preparation
prepini <- function(RT, Resp) {
RT.new <- as.matrix(RT)
RT.new[RT.new== 0] <- NA
num.RT <- RT.new
num.RT[is.na(num.RT)] <-1
logRTs <- log(num.RT)
ini<- list(RT <- RT.new,
Resp <- as.data.frame(Resp),
al_hat <- 1/apply(logRTs,2,sd),
be_hat <- apply(logRTs,2,mean),
sp_hat <- mean(be_hat) - apply(logRTs,1,mean),
prec.sp <- 1,
mu.ipar <- c(mean(al_hat),mean(be_hat)),
prec.ipar <- diag(1,2,2)
)
names(ini) <- c("RT", "Resp", "ini.alpha", "ini.beta", "ini.speed",
"ini.prec.speed", "ini.mu.ipar", "ini.prec.ipar")
ini <- list(ini)
return(ini)
}
Unsupervised.Summary <- (list(
"Detected Cheating Cases Using Kmeans" = det.A,
"Kmeas Results" = kmeans.cm,
"Detected Cheating Cases Using FMM" = det.m.A,
"FMM Results" = mixmul.cm))
return(Unsupervised.Summary)
#### data preparation
prepini <- function(RT, Resp) {
RT.new <- as.matrix(RT)
RT.new[RT.new== 0] <- NA
num.RT <- RT.new
num.RT[is.na(num.RT)] <-1
logRTs <- log(num.RT)
ini<- list(RT <- RT.new,
Resp <- as.data.frame(Resp),
al_hat <- 1/apply(logRTs,2,sd),
be_hat <- apply(logRTs,2,mean),
sp_hat <- mean(be_hat) - apply(logRTs,1,mean),
prec.sp <- 1,
mu.ipar <- c(mean(al_hat),mean(be_hat)),
prec.ipar <- diag(1,2,2)
)
names(ini) <- c("RT", "Resp", "ini.alpha", "ini.beta", "ini.speed",
"ini.prec.speed", "ini.mu.ipar", "ini.prec.ipar")
ini <- list(ini)
return(ini)
}
### calculating IRT and RT based person-fit indexes
prim <- function(ini) {
model <- "
Poisson model...
model {
for (i in 1:N) {
for (j in 1:m) {
RT[i,j] ~ dlnorm(be[j] - sp[i], al[j]^2)
}
sp[i] ~ dnorm(0, prec.sp)
}
prec.sp ~ dgamma(.001,.001)
sd.sp <- sqrt(1/prec.sp)
for (j in 1:m) {
al[j] <- ipar[j,1]
be[j] <- ipar[j,2]
ipar[j,1:2] ~ dmnorm(mu.ipar[1:2], prec.ipar[1:2,1:2])
}
mu <- c(1,3.5)
V[1,1] <- 5
V[2,1] <- 0
V[1,2] <- 0
V[2,2] <- 5
mu.ipar[1:2] ~ dmnorm(mu[1:2], prec.ipar[1:2,1:2])
prec.ipar[1:2,1:2] ~ dwish(V[1:2,1:2], 2)
var.ipar[1:2,1:2] <- inverse(prec.ipar[1:2,1:2])
}
Data{
list(RT = structure(.Data = ini[[1]],
.Dim = c(nrow(ini[[1]]), ncol(ini[[1]]))),N = nrow(ini[[1]]), m = ncol(ini[[1]]))
}
Inits{
list( sp=ini[[5]], prec.sp=ini[[6]],ipar=cbind(ini[[3]], ini[[4]]), mu.ipar=ini[[7]], prec.ipar=ini[[8]])
}
Inits{
list( sp=ini[[5]], prec.sp=ini[[6]],ipar=cbind(ini[[3]], ini[[4]]), mu.ipar=ini[[7]], prec.ipar=ini[[8]])
}
"
out <- run.jags(model, n.chains = 2, burnin = 1000,
sample = 8000, adapt = 2000, monitor=c("al","be","mu.ipar","var.ipar","sp","sd.sp"),
)
RT <- ini[[1]]
out <- run.jags(model, n.chains = 2, burnin = 1000,
sample = 8000, adapt = 2000, monitor=c("al","be","mu.ipar","var.ipar","sp","sd.sp"),
)
prepini(RT, Resp)
png(icc_path)
plot(model, type="trace")
